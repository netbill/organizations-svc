// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package pgdb

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countRoles = `-- name: CountRoles :one
SELECT COUNT(*)::bigint
FROM roles r
WHERE r.agglomeration_id = $1::uuid

    AND (
        $2::uuid IS NULL
        OR EXISTS (
            SELECT 1
            FROM member_roles mr
            WHERE mr.role_id = r.id
                AND mr.member_id = $2::uuid
        )
    )

    AND (
        $3::text[] IS NULL
        OR EXISTS (
            SELECT 1
            FROM role_permissions rp2
            JOIN permissions p2 ON p2.id = rp2.permission_id
            WHERE rp2.role_id = r.id
                AND p2.code = ANY($3::text[])
    )
)
`

type CountRolesParams struct {
	AgglomerationID uuid.UUID
	MemberID        uuid.NullUUID
	PermissionCodes []string
}

func (q *Queries) CountRoles(ctx context.Context, arg CountRolesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRoles, arg.AgglomerationID, arg.MemberID, pq.Array(arg.PermissionCodes))
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (
    id,
    agglomeration_id,
    head,
    editable,
    rank,
    name
) VALUES (
    $1::uuid,
    $2::uuid,
    COALESCE($3::boolean, false),
    COALESCE($4::boolean, true),
    COALESCE($5::int, 0),
    $6::text
)
RETURNING id, agglomeration_id, head, editable, rank, name, created_at, updated_at
`

type CreateRoleParams struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, createRole,
		arg.ID,
		arg.AgglomerationID,
		arg.Head,
		arg.Editable,
		arg.Rank,
		arg.Name,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE id = $1::uuid
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRole, id)
	return err
}

const filterRoles = `-- name: FilterRoles :many
SELECT
    r.id,
    r.agglomeration_id,
    r.head,
    r.editable,
    r.rank,
    r.name,
    r.created_at,
    r.updated_at,

    COALESCE(
        json_agg(
            json_build_object(
            'permission_id', p.id,
            'code', p.code,
            'description', p.description
            )
        ) FILTER (WHERE p.id IS NOT NULL),
        '[]'
    ) AS permissions
FROM roles r
LEFT JOIN role_permissions rp ON rp.role_id = r.id
LEFT JOIN permissions p ON p.id = rp.permission_id
WHERE r.agglomeration_id = $1::uuid

    AND (
        $2::uuid IS NULL
        OR EXISTS (
            SELECT 1
            FROM member_roles mr
            WHERE mr.role_id = r.id
                AND mr.member_id = $2::uuid
        )
    )
    AND (
        $3::text[] IS NULL
        OR EXISTS (
            SELECT 1
            FROM role_permissions rp2
            JOIN permissions p2 ON p2.id = rp2.permission_id
            WHERE rp2.role_id = r.id
                AND p2.code = ANY($3::text[])
        )
    )

    AND (
        ($4::int IS NULL AND $5::uuid IS NULL)
        OR (r.rank, r.id) > ($4::int, $5::uuid)
    )

GROUP BY r.id
ORDER BY r.rank ASC, r.id ASC
LIMIT $6::int
`

type FilterRolesParams struct {
	AgglomerationID uuid.UUID
	MemberID        uuid.NullUUID
	PermissionCodes []string
	CursorRank      sql.NullInt32
	CursorID        uuid.NullUUID
	Limit           int32
}

type FilterRolesRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Permissions     interface{}
}

func (q *Queries) FilterRoles(ctx context.Context, arg FilterRolesParams) ([]FilterRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, filterRoles,
		arg.AgglomerationID,
		arg.MemberID,
		pq.Array(arg.PermissionCodes),
		arg.CursorRank,
		arg.CursorID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterRolesRow
	for rows.Next() {
		var i FilterRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.AgglomerationID,
			&i.Head,
			&i.Editable,
			&i.Rank,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Permissions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRole = `-- name: GetRole :one
SELECT
    r.id,
    r.agglomeration_id,
    r.head,
    r.editable,
    r.rank,
    r.name,
    r.created_at,
    r.updated_at,

    COALESCE(
        json_agg(
            json_build_object(
                'permission_id', p.id,
                'code', p.code
                'description', p.description
            )
        ) FILTER (WHERE p.id IS NOT NULL),
        '[]'
    ) AS permissions
FROM roles r
LEFT JOIN role_permissions rp ON rp.role_id = r.id
LEFT JOIN permissions p ON p.id = rp.permission_id
WHERE r.id = $1
GROUP BY r.id
`

type GetRoleRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Permissions     interface{}
}

func (q *Queries) GetRole(ctx context.Context, id uuid.UUID) (GetRoleRow, error) {
	row := q.db.QueryRowContext(ctx, getRole, id)
	var i GetRoleRow
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Permissions,
	)
	return i, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET
    rank = COALESCE($1::int, rank),

    name = COALESCE($2::text, name),

    updated_at = now()
WHERE id = $3::uuid
RETURNING id, agglomeration_id, head, editable, rank, name, created_at, updated_at
`

type UpdateRoleParams struct {
	Rank sql.NullInt32
	Name sql.NullString
	ID   uuid.UUID
}

// head = COALESCE(sqlc.narg('head')::boolean, head),
// editable = COALESCE(sqlc.narg('editable')::boolean, editable),
func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.Rank, arg.Name, arg.ID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
