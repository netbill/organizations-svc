// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package pgdb

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRole = `-- name: CreateRole :one
INSERT INTO roles (
    id,
    agglomeration_id,
    head,
    editable,
    rank,
    name
) VALUES (
    $1::uuid,
    $2::uuid,
    COALESCE($3::boolean, false),
    COALESCE($4::boolean, true),
    COALESCE($5::int, 0),
    $6::text
)
RETURNING id, agglomeration_id, head, editable, rank, name, created_at, updated_at
`

type CreateRoleParams struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            sql.NullBool
	Editable        sql.NullBool
	Rank            sql.NullInt32
	Name            string
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, createRole,
		arg.ID,
		arg.AgglomerationID,
		arg.Head,
		arg.Editable,
		arg.Rank,
		arg.Name,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE id = $1::uuid
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRole, id)
	return err
}

const filterRole = `-- name: FilterRole :many
SELECT
    r.id,
    r.agglomeration_id,
    r.head,
    r.editable,
    r.rank,
    r.name,
    r.created_at,
    r.updated_at,

    COALESCE(
        json_agg(
            json_build_object(
                'permission_id', p.id,
                'code', p.code
            )
        ) FILTER (WHERE p.id IS NOT NULL),
        '[]'
    ) AS permissions
FROM roles r
LEFT JOIN role_permissions rp ON rp.role_id = r.id
LEFT JOIN permissions p ON p.id = rp.permission_id
WHERE r.agglomeration_id = $1
    AND (
        ($2 IS NULL AND $3 IS NULL)
        OR (r.rank, r.id) > ($2, $3)
    )
GROUP BY r.id
ORDER BY r.rank ASC, r.id ASC
LIMIT $4
`

type FilterRoleParams struct {
	AgglomerationID uuid.UUID
	Column2         interface{}
	Column3         interface{}
	Limit           int32
}

type FilterRoleRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Permissions     interface{}
}

func (q *Queries) FilterRole(ctx context.Context, arg FilterRoleParams) ([]FilterRoleRow, error) {
	rows, err := q.db.QueryContext(ctx, filterRole,
		arg.AgglomerationID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterRoleRow
	for rows.Next() {
		var i FilterRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.AgglomerationID,
			&i.Head,
			&i.Editable,
			&i.Rank,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Permissions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRole = `-- name: GetRole :one
SELECT
    r.id,
    r.agglomeration_id,
    r.head,
    r.editable,
    r.rank,
    r.name,
    r.created_at,
    r.updated_at,

    COALESCE(
        json_agg(
            json_build_object(
                'permission_id', p.id,
                'code', p.code
            )
        ) FILTER (WHERE p.id IS NOT NULL),
        '[]'
    ) AS permissions
FROM roles r
LEFT JOIN role_permissions rp ON rp.role_id = r.id
LEFT JOIN permissions p ON p.id = rp.permission_id
WHERE r.id = $1
GROUP BY r.id
`

type GetRoleRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Permissions     interface{}
}

func (q *Queries) GetRole(ctx context.Context, id uuid.UUID) (GetRoleRow, error) {
	row := q.db.QueryRowContext(ctx, getRole, id)
	var i GetRoleRow
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Permissions,
	)
	return i, err
}

const updateRole = `-- name: UpdateRole :exec
UPDATE roles
SET
    rank = COALESCE($1::int, rank),

    name = COALESCE($2::text, name),

    updated_at = now()
WHERE id = $3::uuid
`

type UpdateRoleParams struct {
	Rank sql.NullInt32
	Name sql.NullString
	ID   uuid.UUID
}

// head = COALESCE(sqlc.narg('head')::boolean, head),
// editable = COALESCE(sqlc.narg('editable')::boolean, editable),
func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateRole, arg.Rank, arg.Name, arg.ID)
	return err
}
