// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cities.sql

package pgdb

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const activateCity = `-- name: ActivateCity :one
UPDATE cities
SET
    status = 'active',
    updated_at = now()
WHERE id = $1::uuid
RETURNING id, agglomeration_id, status, slug, name, icon, banner, created_at, updated_at
`

func (q *Queries) ActivateCity(ctx context.Context, id uuid.UUID) (City, error) {
	row := q.db.QueryRowContext(ctx, activateCity, id)
	var i City
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Status,
		&i.Slug,
		&i.Name,
		&i.Icon,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countCities = `-- name: CountCities :one
SELECT COUNT(*)::bigint
FROM cities
WHERE
    ($1::uuid IS NULL OR agglomeration_id = $1::uuid)
    AND ($2::cities_status IS NULL OR status = $2::cities_status)
    AND ($3::text IS NULL OR name ILIKE ('%' || $3::text || '%'))
`

type CountCitiesParams struct {
	AgglomerationID uuid.NullUUID
	Status          NullCitiesStatus
	NameLike        sql.NullString
}

func (q *Queries) CountCities(ctx context.Context, arg CountCitiesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCities, arg.AgglomerationID, arg.Status, arg.NameLike)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createCity = `-- name: CreateCity :one
INSERT INTO cities (
    agglomeration_id,
    slug,
    name,
    icon,
    banner
) VALUES (
    $1::uuid,
    $2::varchar,
    $3::varchar,
    $4::text,
    $5::text
)
RETURNING id, agglomeration_id, status, slug, name, icon, banner, created_at, updated_at
`

type CreateCityParams struct {
	AgglomerationID uuid.NullUUID
	Slug            sql.NullString
	Name            string
	Icon            sql.NullString
	Banner          sql.NullString
}

func (q *Queries) CreateCity(ctx context.Context, arg CreateCityParams) (City, error) {
	row := q.db.QueryRowContext(ctx, createCity,
		arg.AgglomerationID,
		arg.Slug,
		arg.Name,
		arg.Icon,
		arg.Banner,
	)
	var i City
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Status,
		&i.Slug,
		&i.Name,
		&i.Icon,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateCity = `-- name: DeactivateCity :one
UPDATE cities
SET
    status = 'inactive',
    updated_at = now()
WHERE id = $1::uuid
RETURNING id, agglomeration_id, status, slug, name, icon, banner, created_at, updated_at
`

func (q *Queries) DeactivateCity(ctx context.Context, id uuid.UUID) (City, error) {
	row := q.db.QueryRowContext(ctx, deactivateCity, id)
	var i City
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Status,
		&i.Slug,
		&i.Name,
		&i.Icon,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCity = `-- name: DeleteCity :exec
DELETE FROM cities
WHERE id = $1::uuid
`

func (q *Queries) DeleteCity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCity, id)
	return err
}

const filterCities = `-- name: FilterCities :many
SELECT id, agglomeration_id, status, slug, name, icon, banner, created_at, updated_at
FROM cities
WHERE
    ($1::uuid IS NULL OR agglomeration_id = $1::uuid)
    AND ($2::cities_status IS NULL OR status = $2::cities_status)
    AND ($3::text IS NULL OR name ILIKE ('%' || $3::text || '%'))
    AND (
        $4::timestamptz IS NULL
        OR (created_at, id) < ($4::timestamptz, $5::uuid)
    )
ORDER BY created_at DESC, id DESC
    LIMIT $6::int
`

type FilterCitiesParams struct {
	AgglomerationID uuid.NullUUID
	Status          NullCitiesStatus
	NameLike        sql.NullString
	AfterCreatedAt  sql.NullTime
	AfterID         uuid.NullUUID
	Limit           int32
}

func (q *Queries) FilterCities(ctx context.Context, arg FilterCitiesParams) ([]City, error) {
	rows, err := q.db.QueryContext(ctx, filterCities,
		arg.AgglomerationID,
		arg.Status,
		arg.NameLike,
		arg.AfterCreatedAt,
		arg.AfterID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []City
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.ID,
			&i.AgglomerationID,
			&i.Status,
			&i.Slug,
			&i.Name,
			&i.Icon,
			&i.Banner,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCityByID = `-- name: GetCityByID :one
SELECT id, agglomeration_id, status, slug, name, icon, banner, created_at, updated_at
FROM cities
WHERE id = $1::uuid
`

func (q *Queries) GetCityByID(ctx context.Context, id uuid.UUID) (City, error) {
	row := q.db.QueryRowContext(ctx, getCityByID, id)
	var i City
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Status,
		&i.Slug,
		&i.Name,
		&i.Icon,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCityBySlug = `-- name: GetCityBySlug :one
SELECT id, agglomeration_id, status, slug, name, icon, banner, created_at, updated_at
FROM cities
WHERE slug = $1::varchar
`

func (q *Queries) GetCityBySlug(ctx context.Context, slug string) (City, error) {
	row := q.db.QueryRowContext(ctx, getCityBySlug, slug)
	var i City
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Status,
		&i.Slug,
		&i.Name,
		&i.Icon,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCity = `-- name: UpdateCity :one
UPDATE cities
SET
    agglomeration_id = COALESCE($1::uuid, agglomeration_id),

    name = COALESCE($2::varchar, name),

    slug = CASE
        WHEN $3::varchar IS NULL THEN slug
        WHEN $3::varchar = '' THEN NULL
        ELSE $3::varchar
    END,

    icon = CASE
        WHEN $4::text IS NULL THEN icon
        WHEN $4::text = '' THEN NULL
        ELSE $4::text
    END,

    banner = CASE
        WHEN $5::text IS NULL THEN banner
        WHEN $5::text = '' THEN NULL
        ELSE $5::text
    END,

    updated_at = now()
WHERE id = $6::uuid
RETURNING id, agglomeration_id, status, slug, name, icon, banner, created_at, updated_at
`

type UpdateCityParams struct {
	AgglomerationID uuid.NullUUID
	Name            sql.NullString
	Slug            sql.NullString
	Icon            sql.NullString
	Banner          sql.NullString
	ID              uuid.UUID
}

func (q *Queries) UpdateCity(ctx context.Context, arg UpdateCityParams) (City, error) {
	row := q.db.QueryRowContext(ctx, updateCity,
		arg.AgglomerationID,
		arg.Name,
		arg.Slug,
		arg.Icon,
		arg.Banner,
		arg.ID,
	)
	var i City
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Status,
		&i.Slug,
		&i.Name,
		&i.Icon,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
