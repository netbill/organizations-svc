// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package pgdbsql

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countRoles = `-- name: CountRoles :one
SELECT COUNT(*)::bigint
FROM roles r
WHERE r.agglomeration_id = $1::uuid

    AND (
        $2::uuid IS NULL
        OR EXISTS (
            SELECT 1
            FROM member_roles mr
            WHERE mr.role_id = r.id
                AND mr.member_id = $2::uuid
        )
    )

    AND (
        $3::text[] IS NULL
        OR EXISTS (
            SELECT 1
            FROM role_permissions rp2
            JOIN permissions p2 ON p2.id = rp2.permission_id
            WHERE rp2.role_id = r.id
                AND p2.code = ANY($3::text[])
    )
)
`

type CountRolesParams struct {
	AgglomerationID uuid.UUID
	MemberID        uuid.NullUUID
	PermissionCodes []string
}

func (q *Queries) CountRoles(ctx context.Context, arg CountRolesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRoles, arg.AgglomerationID, arg.MemberID, pq.Array(arg.PermissionCodes))
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createRoleAtRank = `-- name: CreateRoleAtRank :one
WITH input AS (
    SELECT
        $1::uuid                AS id,
        $2::uuid  AS agglomeration_id,
        COALESCE($3::boolean, false)     AS head,
        COALESCE($4::boolean, true)  AS editable,
        COALESCE($5::int, 0)            AS new_rank,
        $6::text              AS name
),
shift AS (
    UPDATE roles r
    SET rank = r.rank + 1,
        updated_at = now()
    WHERE r.agglomeration_id = (SELECT agglomeration_id FROM input)
        AND (SELECT new_rank FROM input) > 0
        AND r.rank >= (SELECT new_rank FROM input)
    RETURNING 1
),
ins AS (
    INSERT INTO roles (id, agglomeration_id, head, editable, rank, name)
    SELECT id, agglomeration_id, head, editable, new_rank, name
    FROM input
    RETURNING id, agglomeration_id, head, editable, rank, name, created_at, updated_at
)
SELECT id, agglomeration_id, head, editable, rank, name, created_at, updated_at FROM ins
`

type CreateRoleAtRankParams struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
}

type CreateRoleAtRankRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) CreateRoleAtRank(ctx context.Context, arg CreateRoleAtRankParams) (CreateRoleAtRankRow, error) {
	row := q.db.QueryRowContext(ctx, createRoleAtRank,
		arg.ID,
		arg.AgglomerationID,
		arg.Head,
		arg.Editable,
		arg.Rank,
		arg.Name,
	)
	var i CreateRoleAtRankRow
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE id = $1::uuid
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRole, id)
	return err
}

const filterRoles = `-- name: FilterRoles :many
SELECT
    r.id,
    r.agglomeration_id,
    r.head,
    r.editable,
    r.rank,
    r.name,
    r.created_at,
    r.updated_at,

    COALESCE(
        json_agg(
            json_build_object(
            'permission_id', p.id,
            'code', p.code,
            'description', p.description
            )
        ) FILTER (WHERE p.id IS NOT NULL),
        '[]'
    ) AS permissions
FROM roles r
LEFT JOIN role_permissions rp ON rp.role_id = r.id
LEFT JOIN permissions p ON p.id = rp.permission_id
WHERE r.agglomeration_id = $1::uuid

    AND (
        $2::uuid IS NULL
        OR EXISTS (
            SELECT 1
            FROM member_roles mr
            WHERE mr.role_id = r.id
                AND mr.member_id = $2::uuid
        )
    )
    AND (
        $3::text[] IS NULL
        OR EXISTS (
            SELECT 1
            FROM role_permissions rp2
            JOIN permissions p2 ON p2.id = rp2.permission_id
            WHERE rp2.role_id = r.id
                AND p2.code = ANY($3::text[])
        )
    )

    AND (
        ($4::int IS NULL AND $5::uuid IS NULL)
        OR (r.rank, r.id) > ($4::int, $5::uuid)
    )

GROUP BY r.id
ORDER BY r.rank ASC, r.id ASC
LIMIT $6::int
`

type FilterRolesParams struct {
	AgglomerationID uuid.UUID
	MemberID        uuid.NullUUID
	PermissionCodes []string
	CursorRank      sql.NullInt32
	CursorID        uuid.NullUUID
	Limit           int32
}

type FilterRolesRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Permissions     interface{}
}

func (q *Queries) FilterRoles(ctx context.Context, arg FilterRolesParams) ([]FilterRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, filterRoles,
		arg.AgglomerationID,
		arg.MemberID,
		pq.Array(arg.PermissionCodes),
		arg.CursorRank,
		arg.CursorID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterRolesRow
	for rows.Next() {
		var i FilterRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.AgglomerationID,
			&i.Head,
			&i.Editable,
			&i.Rank,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Permissions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRole = `-- name: GetRole :one
SELECT
    r.id,
    r.agglomeration_id,
    r.head,
    r.editable,
    r.rank,
    r.name,
    r.created_at,
    r.updated_at,

    COALESCE(
        json_agg(
            json_build_object(
                'permission_id', p.id,
                'code', p.code
                'description', p.description
            )
        ) FILTER (WHERE p.id IS NOT NULL),
        '[]'
    ) AS permissions
FROM roles r
LEFT JOIN role_permissions rp ON rp.role_id = r.id
LEFT JOIN permissions p ON p.id = rp.permission_id
WHERE r.id = $1
GROUP BY r.id
`

type GetRoleRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Permissions     interface{}
}

func (q *Queries) GetRole(ctx context.Context, id uuid.UUID) (GetRoleRow, error) {
	row := q.db.QueryRowContext(ctx, getRole, id)
	var i GetRoleRow
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Permissions,
	)
	return i, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET
    name = COALESCE($1::text, name),

    updated_at = now()
WHERE id = $2::uuid
RETURNING id, agglomeration_id, head, editable, rank, name, created_at, updated_at
`

type UpdateRoleParams struct {
	Name sql.NullString
	ID   uuid.UUID
}

// head = COALESCE(sqlc.narg('head')::boolean, head),
// editable = COALESCE(sqlc.narg('editable')::boolean, editable),
func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.Name, arg.ID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRoleRank = `-- name: UpdateRoleRank :one
WITH cur AS (
    SELECT id, agglomeration_id, rank AS old_rank
    FROM roles
    WHERE id = $1::uuid
    FOR UPDATE
),
upd AS (
    UPDATE roles r
    SET
        rank = CASE
            WHEN r.id = (SELECT id FROM cur) THEN $2::int

            WHEN (SELECT old_rank FROM cur) < $2::int
                AND r.rank > (SELECT old_rank FROM cur)
                AND r.rank <= $2::int
            THEN r.rank - 1

            WHEN (SELECT old_rank FROM cur) > $2::int
                AND r.rank >= $2::int
                AND r.rank < (SELECT old_rank FROM cur)
            THEN r.rank + 1

            ELSE r.rank
        END,
        updated_at = now()
    WHERE r.agglomeration_id = (SELECT agglomeration_id FROM cur)
    AND (SELECT old_rank FROM cur) <> 0
    AND $2::int > 0
    RETURNING r.id, r.agglomeration_id, r.head, r.editable, r.rank, r.name, r.created_at, r.updated_at
)
SELECT id, agglomeration_id, head, editable, rank, name, created_at, updated_at
FROM upd
WHERE id = $1::uuid
`

type UpdateRoleRankParams struct {
	ID      uuid.UUID
	NewRank int32
}

type UpdateRoleRankRow struct {
	ID              uuid.UUID
	AgglomerationID uuid.UUID
	Head            bool
	Editable        bool
	Rank            int32
	Name            string
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) UpdateRoleRank(ctx context.Context, arg UpdateRoleRankParams) (UpdateRoleRankRow, error) {
	row := q.db.QueryRowContext(ctx, updateRoleRank, arg.ID, arg.NewRank)
	var i UpdateRoleRankRow
	err := row.Scan(
		&i.ID,
		&i.AgglomerationID,
		&i.Head,
		&i.Editable,
		&i.Rank,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
